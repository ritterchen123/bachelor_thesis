\chapter{Aussagekräftigerer Titel}\label{chap:approach}

Lets go back to the example  from the beginning. The problem was that both agents $a$ and $b$ wanted to pull the lever to their own goal which results in infinite executions. This problem can be eliminated by introducing a token. With a token, only the player that has the token gets to execute an action. If the agent is done with their own actions, then they can pass the token on to the next player.

\section{Infinite Executions}

\extend{einleitender Satz}
\draft{We are now going to describe a function that takes a regular planning task and tokenize that task. The goal with the tokens is that only one player gets to make a move at a time.}

Given a regular planning task $\Pi = \langle s_0, A, \omega, \gamma \rangle $, the function \textit{tokenize} will transform the regular planning task into a tokenized planning task so that for all $a \in A$:
 if $a = \langle pre, \textit{eff} \rangle$, then
   $tokenize(a) =\langle pre \wedge has(\omega(a), token), \textit{eff} \rangle$. \\
Further we define an action
    $ giveToken^{ij} = \langle has(i, token), \neg has(i, token) \wedge has (j, token) \rangle $
    for all $i,j \in \mathcal{A}$. \\
Then $ A^{Token}=\{tokenize(a)|a \in A\} \cup \{giveToken^{ij}|i,j \in \mathcal{A}, i \not = j\}$. \\
Moreover: $\omega^{Token}(tokenize(a))= \omega(a)$ for all $a \in A$,
and $\omega^{Token}(giveToken^{ij}) = i$ for all $i,j \in \mathcal{A}$. \\
Then $ \Pi^{\text{Token}} = \langle s_0, A ^{\text{Token}}, \omega ^{\text{Token}}, \gamma \rangle $.

\extend{hier auf die verschiedenen Token Typen eingehen}

\extend{überleitender Satz}

\begin{theorem}
Under the condition of optimal plans one can prevent the apperance of infinite executions in solvable games with asynchronus execution order with the introduction of a token based execution order.
\end{theorem}

\begin{proof}[proof sketch]
  The game is finished when the agent that has the token reaches a goal state. When an agent that has a plan with the subjective cost of $n+m, m \leq 1$, that agent will start executing that plan and if needed, hand over the token to the next player. The agent will always decrease the subjective cost to n because handing over the token will also decrease the subjective cost. Because every agent decreases the subjective cost, the game is executable in infinite executions.
\end{proof}


\section{Deadlocks}

A deadlock for a policy profile $(\pi_i)_{i \in \mathcal{A}}$ is a global state such that
\todo{hier noch die unterpunkte umschreiben}
\begin{enumerate}
  \item $s$ is not a goal state \\
    Something still needs to be done
  \item $s \in \text{Dom}(\pi_i)$ for some $i \in \mathcal{A}$ \\
    Someone wants something to be done
  \item $\omega(a) \neq i$ for all $i \in \mathcal{A}$ and $a \in \pi_i(s)$ \\
    Nothing will be done because of incompatible individual policies
\end{enumerate}

This can be seen in the following example: The two agents from before, Anne and Bill have to empty out the dishwasher. They each have a preference against doing this, since they both spend time (costs) to do this. \extend{hier vielleicht formal noch mal darstellen?}
In this example you can see that each agent expects the other agent to act, therefore no agent will act.

Up to this point, the token has given the player that has it the right to perform an action, a right that none of the other players have. But tokens could also force a player to perform an action.

Consider the definition from before with some changes marked in color: \\
Given a regular planning task $\Pi = \langle s_0, A, \omega, \gamma \rangle $, the function \textit{tokenize} will transform the regular planning task into a tokenized planning task so that for all $a \in A$: \\
 if $a = \langle pre, \textit{eff} \rangle$, then
   $tokenize(a) =\langle pre \wedge has(\omega(a), token), \textit{eff } {\color{UniRed} \wedge doneAction(a)})$ \\
Former we define an Action
    $ giveToken^{ij} = \langle has(i, token) {\color{UniRed}\wedge doneAction(i)}, \neg has(i, token) \wedge has (j, token) {\color{UniRed} \wedge \neg doneAction(i)} \rangle $
    for all $i,j \in \mathcal{A}$
    \\
Then $ A^{Token}=\{tokenize(a)|a \in A\} \cup \{giveToken^{ij}|i,j \in \mathcal{A}, i \not = j\}
$ \\
Moreover: $\omega^{Token}(tokenize(a))= \omega(a)$ for all $a \in A$,
and $\omega^{Token}(giveToken^{ij}) = i$ for all $i,j \in \mathcal{A}$. \\
Then $ \Pi^{\text{Token}} = \langle s_0, A ^{\text{Token}}, \omega ^{\text{Token}}, \gamma \rangle $

The changes imply that each agent can only pass on the token when that agent has performed an action.

\begin{theorem}
Under the condition of optimal plans one can prevent the apperance of deadlocks in solvable games with asynchron execution order with the introduction of a token based execution order.
\end{theorem}

\begin{proof}[proof sketch]
  Before any player can give away the token, that player has to perform an action. If a player that has found a plan gets the token, that agent first has to do an action. This contradics the definition of a deadlock.
\end{proof}








A deadlock is different from a dead end. In a dead end, none of the agents' policies prescribe an action, not even for another agent. In the definition (2) above it becomes obvious that these are two different things.














































\newpage

The problem with the tokens is the allocation of the token in the beginning. Each allocation type brings advantages, but also has some disadvantages. Lets start with the straightforward allocation we used up to now.


\section{Asynchron execution order}
  The first execution order is seemingly random. Some undefined agent has the token in the beginning. The advantage is that you do not have to define anything in the beginning, but this is also a disadvantage, since this token is defined, but the agent that has it in the beginning is not.




  There are three other ways to introduce a token to this game.
  \begin{enumerate}
    \item Tabel token - the token is lying on a table and one of the agents can take the token in the beginning. \\
    The disadvantage becomes clear in the example with the diswasher. No agent would take the token.
    \item give token - in the specification of the game it is also specified which agent will have the token in the beginning. \\
    The problem with this introduction is that in every new game, this has to be written in the definition of the game. In order for the game to be efficient, it should be given to a player who has found a plan.
    \item random token - the token is given to a random agent in the beginning. If that agent can not preform any action it can pass the token to a player who can. \\
    An agent who knows nothing and has no action will prevent the game from ever reaching a goal state.
  \end{enumerate}

Each version has its own drawbacks. In every game, you have to know the occuring problem beforehand to know whick token allocation is efficient.






























%\section{Token versions}

%\subsection{table token}
%  $
%  A=
%  \{\text{Move\_R}(agt,obj,pos,token) \ | \ agt \in \mathcal{A} \ \& \ obj \in Obj \ \& \ pos \in \{ -2;1\}\} \cup \\
%  \{\text{Move\_L}(agt,obj,pos,token) \ | \ agt \in \mathcal{A} \ \& \ obj \in Obj \ \& \ pos \in \{ -1;2\}\} \\
%  \{\text{Take\_Token}(agt, token) \ | \ agt \in \mathcal{A} \ \& \ token \in Token \} \\
%  \{\text{Give\_Token}(agt, token, otheragt) \ | \ agt \in \mathcal{A} \ \& \ token \in Token \ \& \ otheragt \in \mathcal{A}\backslash agt \} \\
%  \text{where} \ \forall \ agt \in \mathcal{A}, pos \in \{ -2;2\}, obj \in Obj , |Token| = 1
%  $
%  \begin{itemize}
%    \item $
%      \text{Move\_R}(agt,obj,pos,token) = \langle \text{At}(obj, pos) \wedge \text{Has}(agt, token) , \text{At}(obj, pos+1) \wedge \neg \text{At}(obj,pos) \rangle
%      $
%    \item $
%      \text{Move\_L}(agt,obj,pos,token) = \langle \text{At}(obj, pos) \wedge \text{Has}(agt, token) , \text{At}(obj, pos-1) \wedge \neg \text{At}(obj,pos) \rangle
  %    $
%    \item $
  %    \text{Take\_Token}(agt, token) = \langle \neg \text{Has}(agt, token) \wedge \text{At}(token, table), \text{Has}(agt, token) \wedge \neg  \text{At}(token, table) \rangle
%      $
%    \item $
%      \text{Give\_Token}(agt, token, otheragt) = \langle
%      \text{Has}(agt, token), \neg \text{Has}(agt, token) \wedge
%      \text{Has}(otheragt, token)
%      \rangle
%    $
%  \end{itemize}

%  $s_0=\{\text{At(Hebel, N)}, \text{At(Token, Table)}\}$

%\subsection{give Token}
%  $
%  A=
%  \{\text{Move\_R}(agt,obj,pos,token) \ | \ agt \in \mathcal{A} \ \& \ obj \in Obj \ \& \ pos \in \{ -2;1\}\} \cup \\
%  \{\text{Move\_L}(agt,obj,pos,token) \ | \ agt \in \mathcal{A} \ \& \ obj \in Obj \ \& \ pos \in \{ -1;2\}\} \\
%  \{\text{Give\_Token}(agt, token, otheragt) \ | \ agt \in \mathcal{A} \ \& \ token \in Token \ \& \ otheragt \in \mathcal{A}\backslash agt \} \\
%  \text{where} \ \forall \ agt \in \mathcal{A}, pos \in \{ -2;2\}, obj \in Obj , |Token| = 1
  %$
  %\begin{itemize}
  %  \item $
    %  \text{Move\_R}(agt,obj,pos,token) = \langle \text{At}(obj, pos) \wedge \text{Has}(agt, token) , \text{At}(obj, pos+1) \wedge \neg \text{At}(obj,pos) \rangle
  %    $
  %  \item $
  %    \text{Move\_L}(agt,obj,pos,token) = \langle \text{At}(obj, pos) \wedge \text{Has}(agt, token) , \text{At}(obj, pos-1) \wedge \neg \text{At}(obj,pos) \rangle
  %    $
  %  \item $
  %    \text{Give\_Token}(agt, token, otheragt) = \langle
  %    \text{Has}(agt, token), \neg \text{Has}(agt, token) \wedge
  %    \text{Has}(otheragt, token)
  %    \rangle
  %  $
  %\end{itemize}

  %$s_0=\{\text{At(Hebel, N), Has(agent} \in \mathcal{A},\text{Token)}\}$

%\subsection{random token}
%  $
%  A=
%  \{\text{Move\_R}(agt,obj,pos,token) \ | \ agt \in \mathcal{A} \ \& \ obj \in Obj \ \& \ pos \in \{ -2;1\}\} \cup \\
%  \{\text{Move\_L}(agt,obj,pos,token) \ | \ agt \in \mathcal{A} \ \& \ obj \in Obj \ \& \ pos \in \{ -1;2\}\} \\
%  \{\text{Give\_Token}(agt, token, otheragt) \ | \ agt \in \mathcal{A} \ \& \ token \in Token \ \& \ otheragt \in \mathcal{A}\backslash agt \} \\
%  \text{where} \ \forall \ agt \in \mathcal{A}, pos \in \{ -2;2\}, obj \in Obj , |Token| = 1
%  $
%  \begin{itemize}
%    \item $
%      \text{Move\_R}(agt,obj,pos,token) = \langle \text{At}(obj, pos) \wedge \text{Has}(agt, token) , \text{At}(obj, pos+1) \wedge \neg \text{At}(obj,pos) \rangle
%      $
%    \item $
%      \text{Move\_L}(agt,obj,pos,token) = \langle \text{At}(obj, pos) \wedge \text{Has}(agt, token) , \text{At}(obj, pos-1) \wedge \neg \text{At}(obj,pos) \rangle
  %    $
  %  \item $
  %    \text{Give\_Token}(agt, token, otheragt) = \langle
  %    \text{Has}(agt, token), \neg \text{Has}(agt, token) \wedge
  %    \text{Has}(otheragt, token)
  %    \rangle
  %  $
  %\end{itemize}

  %$s_0=\{\text{At(Hebel, N), Has(randomagent} \in \mathcal{A},\text{Token)}\}$
