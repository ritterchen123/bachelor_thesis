\chapter{Approach}\label{chap:approach}

Lets go back to the example  from the beginning. The problem was that both agents a and b wanted to pull the lever to their own goal which results in infinite executions. This problem can be eliminated by introducing a token. With a token, only the player that has the token gets to execute an action. If the agent is done with their own actions, then they can pass the token on to the next player.

\subsection{Tokens}

Given a regular planning task $\Pi = \langle s_0, A, \omega, \gamma \rangle $, the function \textit{tokenize} will transform the regular planning task into a tokenized planning task so that for all $a \in A$:
 if $a = \langle pre, \textit{eff} \rangle$, then
   $tokenize(a) =\langle pre \wedge has(\omega(a), token, \textit{eff})$ \\
Former we define an Action
    $ giveToken^{ij} = \langle has(i, token), \neg has(i, token) \wedge has (j, token) \rangle $
    for all $i,j \in \mathcal{A}$ \\
Then $ A^{Token}=\{tokenize(a)|a \in A\} \cup \{giveToken^{ij}|i,j \in \mathcal{A}, i \not = j\}
$ \\
Moreover: $\omega^{Token}(tokenize(a))= \omega(a)$ for all $a \in A$,
and $\omega^{Token}(giveToken^{ij}) = i$ for all $i,j \in \mathcal{A}$. \\
Then $ \Pi^{\text{Token}} = \langle s_0, A ^{\text{Token}}, \omega ^{\text{Token}}, \gamma \rangle $
\todo{Beschreibung fehlt}

\begin{theorem}
Under the condition of optimal plans one can prevent the apperance of infinite executions in solvable games with asynchron execution order with the introduction of a token based execution order.
\end{theorem}

\begin{proof}[proof sketch]
  The game is finished when the Agend that has the token reaches a goal state. When an agend that has a plan with the subjective cost of $n+m, m \leq 1$, that agent will start executing that plan and if needed, hand over the token to the next player. The agend will always decrease the subjective cost to n because handing over the token will also decrease the subjective cost. Because every agent decreases the subjective cost, the game is executable in infinite executions.
\end{proof}
















\newpage






A deadlock for a policy profile $(\pi_i)_{i \in \mathcal{A}}$ is a global state such that
\begin{enumerate}
  \item $s$ is not a goal state
  \item $s \in \text{Dom}(\pi_i)$ for some $i \in \mathcal{A}$
  \item $\omega(a) \neq i$
\end{enumerate}
for all $i \in \mathcal{A}$ and $a \in \pi_i(s)$


Up to this point, the token has given the player that has it the right to perform an action, a right that none of the other players have. But tokens could also force a player to perform an action.

Consider the following problem: The two agents from before, Anne and Bill have to empty out the dishwasher. They each have a preference against doing this, since they both spend time (costs) to do this. \extend{hier vielleicht formal noch mal darstellen?}
In this example you can see that each agent expects the other agent to act, therefore no agent will act.

Here the introduction of tokens forces a player to make a move because the player that has the token has to perform an action. In this example, every action reaches a goal state, even if it is not in the own players policy.







A deadlock is different from a dead end. In a dead end, none of the agents' policies prescribe an action, not even for another agent. In the definition (2) above it becomes obvious that these are two different things.














































\newpage

The problem with the tokens is the allocation of the token in the beginning. Consider the following example as the main example in this chapter.


\section{Lever Problem}
  The lever has a position betreen -2 and 2.\\
  There are two players that each want to move a lever in a direction. Player 1s' goal is to move the lever to the left, to the position -2 and player 2s' goal is to move the lever to the right, to the positon 2. They do not know the other players' goal and they do not know if there is another goal than their own goal.

\section{Asynchron execution order}
  The first possibility is that the players move asynchron, seemingly random. They each have and action to move the lever to the right and to the left. In the beginning the lever is in the middle.

  $
  A=
  \{\text{Move\_R}(agt,obj,pos) \ | \ agt \in \mathcal{A} \ \& \ obj \in Obj \ \& \ pos \in \{ -2;1\}\} \cup \\
  \{\text{Move\_L}(agt,obj,pos) \ | \ agt \in \mathcal{A} \ \& \ obj \in Obj \ \& \ pos \in \{ -1;2\}\} \\
  \text{where} \ \forall \ agt \in \mathcal{A}, pos \in \{ -2;2\}, obj \in Obj ,
  $
  \begin{itemize}
    \item $
      \text{Move\_R}(obj,pos) = \langle \text{At}(obj, pos) , \text{At}(obj, pos+1) \wedge \neg \text{At}(obj,pos) \rangle
      $
    \item $
      \text{Move\_L}(obj,pos) = \langle \text{At}(obj, pos) , \text{At}(obj, pos-1) \wedge \neg \text{At}(obj,pos) \rangle
      $
  \end{itemize}
  $\mathcal{A}= \{Player1, Player2\}$ \\
  $\varphi^{Player1}_g = \text{At(lever},-2)$ \todo{das g hier muss anders} \\
  $\varphi^{Player2}_g = \text{At(lever},2)$ \\
  $\varphi_g = \text{At(lever,L}_2) \vee \text{At(lever,R}_2)$ ? \\
  $s_0 = \{\text{At(lever}, 0) \}$

  \todo{Die Spielabfolge und das Problem ausf√ºhrlich formulieren}

  The agents here only have an incentive to move the lever in the direction towards their own goal. One possible execution would be that the agents each move the lever one step towards their goal and the other agent would move the lever back to the starting position. This is a infinite sequence which is not successful, no player would reach any goal.

  There are three ways to introduce a token to this game.
  \begin{enumerate}
    \item Tabel token - the token is lying on a table and one of the agents can take the token in the beginning. \\
    The problem here is in the example before with the dishwasher. In this example, no player would take the token.
    \item give token - in the specification of the game it is also specified which agent will have the token in the beginning. \\
    The problem with this introduction is that in every new game, this has to be written in the definition of the game. It has to be decided in the beginning.
    \item random token - the token is given to a random agent in the beginning. If that agent can not preform any action it can pass the token to a player who can. \\
    An agent who knows nothing and has no action will prevent the game from ever reaching a goal state.
  \end{enumerate}

\section{Token versions}

\subsection{table token}
  $
  A=
  \{\text{Move\_R}(agt,obj,pos,token) \ | \ agt \in \mathcal{A} \ \& \ obj \in Obj \ \& \ pos \in \{ -2;1\}\} \cup \\
  \{\text{Move\_L}(agt,obj,pos,token) \ | \ agt \in \mathcal{A} \ \& \ obj \in Obj \ \& \ pos \in \{ -1;2\}\} \\
  \{\text{Take\_Token}(agt, token) \ | \ agt \in \mathcal{A} \ \& \ token \in Token \} \\
  \{\text{Give\_Token}(agt, token, otheragt) \ | \ agt \in \mathcal{A} \ \& \ token \in Token \ \& \ otheragt \in \mathcal{A}\backslash agt \} \\
  \text{where} \ \forall \ agt \in \mathcal{A}, pos \in \{ -2;2\}, obj \in Obj , |Token| = 1
  $
  \begin{itemize}
    \item $
      \text{Move\_R}(agt,obj,pos,token) = \langle \text{At}(obj, pos) \wedge \text{Has}(agt, token) , \text{At}(obj, pos+1) \wedge \neg \text{At}(obj,pos) \rangle
      $
    \item $
      \text{Move\_L}(agt,obj,pos,token) = \langle \text{At}(obj, pos) \wedge \text{Has}(agt, token) , \text{At}(obj, pos-1) \wedge \neg \text{At}(obj,pos) \rangle
      $
    \item $
      \text{Take\_Token}(agt, token) = \langle \neg \text{Has}(agt, token) \wedge \text{At}(token, table), \text{Has}(agt, token) \wedge \neg  \text{At}(token, table) \rangle
      $
    \item $
      \text{Give\_Token}(agt, token, otheragt) = \langle
      \text{Has}(agt, token), \neg \text{Has}(agt, token) \wedge
      \text{Has}(otheragt, token)
      \rangle
    $
  \end{itemize}

  $s_0=\{\text{At(Hebel, N)}, \text{At(Token, Table)}\}$

\subsection{give Token}
  $
  A=
  \{\text{Move\_R}(agt,obj,pos,token) \ | \ agt \in \mathcal{A} \ \& \ obj \in Obj \ \& \ pos \in \{ -2;1\}\} \cup \\
  \{\text{Move\_L}(agt,obj,pos,token) \ | \ agt \in \mathcal{A} \ \& \ obj \in Obj \ \& \ pos \in \{ -1;2\}\} \\
  \{\text{Give\_Token}(agt, token, otheragt) \ | \ agt \in \mathcal{A} \ \& \ token \in Token \ \& \ otheragt \in \mathcal{A}\backslash agt \} \\
  \text{where} \ \forall \ agt \in \mathcal{A}, pos \in \{ -2;2\}, obj \in Obj , |Token| = 1
  $
  \begin{itemize}
    \item $
      \text{Move\_R}(agt,obj,pos,token) = \langle \text{At}(obj, pos) \wedge \text{Has}(agt, token) , \text{At}(obj, pos+1) \wedge \neg \text{At}(obj,pos) \rangle
      $
    \item $
      \text{Move\_L}(agt,obj,pos,token) = \langle \text{At}(obj, pos) \wedge \text{Has}(agt, token) , \text{At}(obj, pos-1) \wedge \neg \text{At}(obj,pos) \rangle
      $
    \item $
      \text{Give\_Token}(agt, token, otheragt) = \langle
      \text{Has}(agt, token), \neg \text{Has}(agt, token) \wedge
      \text{Has}(otheragt, token)
      \rangle
    $
  \end{itemize}

  $s_0=\{\text{At(Hebel, N), Has(agent} \in \mathcal{A},\text{Token)}\}$

\subsection{random token}
  $
  A=
  \{\text{Move\_R}(agt,obj,pos,token) \ | \ agt \in \mathcal{A} \ \& \ obj \in Obj \ \& \ pos \in \{ -2;1\}\} \cup \\
  \{\text{Move\_L}(agt,obj,pos,token) \ | \ agt \in \mathcal{A} \ \& \ obj \in Obj \ \& \ pos \in \{ -1;2\}\} \\
  \{\text{Give\_Token}(agt, token, otheragt) \ | \ agt \in \mathcal{A} \ \& \ token \in Token \ \& \ otheragt \in \mathcal{A}\backslash agt \} \\
  \text{where} \ \forall \ agt \in \mathcal{A}, pos \in \{ -2;2\}, obj \in Obj , |Token| = 1
  $
  \begin{itemize}
    \item $
      \text{Move\_R}(agt,obj,pos,token) = \langle \text{At}(obj, pos) \wedge \text{Has}(agt, token) , \text{At}(obj, pos+1) \wedge \neg \text{At}(obj,pos) \rangle
      $
    \item $
      \text{Move\_L}(agt,obj,pos,token) = \langle \text{At}(obj, pos) \wedge \text{Has}(agt, token) , \text{At}(obj, pos-1) \wedge \neg \text{At}(obj,pos) \rangle
      $
    \item $
      \text{Give\_Token}(agt, token, otheragt) = \langle
      \text{Has}(agt, token), \neg \text{Has}(agt, token) \wedge
      \text{Has}(otheragt, token)
      \rangle
    $
  \end{itemize}

  $s_0=\{\text{At(Hebel, N), Has(randomagent} \in \mathcal{A},\text{Token)}\}$
